# Excel Parser Implementation Guide

## üéØ Goal
Parse Excel files (generated by our system or manually edited) back into structured data for Word document generation or QA processing.

## üì¶ Package
We already have `xlsx` installed from Phase 1. No new dependencies needed!

## üèóÔ∏è File: `/lib/excelParser.js`

### Core Function Signature
```javascript
/**
 * Parse an Excel file into structured data
 * @param {File} file - The .xlsx file from FileDropZone
 * @returns {Promise<ParsedExcel>}
 */
export async function parseExcelFile(file) {
  // Implementation
}

/**
 * ParsedExcel structure:
 * {
 *   markets: string[],           // All market codes found (e.g., ["en-US", "es-MX"])
 *   rows: [
 *     {
 *       deliverable: string,     // Section name
 *       field: string,           // Field name
 *       content: {
 *         'en-US': string,       // Content for each market
 *         'es-MX': string,
 *         // ...
 *       }
 *     }
 *   ],
 *   requirements: [              // From Tab 2 (if exists)
 *     {
 *       deliverable: string,
 *       assetName: string,
 *       width: number,
 *       height: number,
 *       maxFileSize: string,
 *       formats: string,
 *       filenameFormat: string,
 *       notes: string
 *     }
 *   ],
 *   metadata: {
 *     filename: string,
 *     tabNames: string[],
 *     parsedAt: Date,
 *     warnings: string[]
 *   }
 * }
 */
```

## üîç Parsing Strategy

### Step 1: Read Excel File
```javascript
import * as XLSX from 'xlsx';

async function readExcelFile(file) {
  const arrayBuffer = await file.arrayBuffer();
  const workbook = XLSX.read(arrayBuffer, { type: 'array' });
  
  return {
    workbook,
    sheetNames: workbook.SheetNames
  };
}
```

### Step 2: Parse Copy Template Tab (Tab 1)
```javascript
function parseCopyTab(worksheet) {
  // Convert sheet to JSON with header row
  const data = XLSX.utils.sheet_to_json(worksheet, { 
    header: 1,  // Use first row as header
    defval: ''  // Default value for empty cells
  });
  
  if (data.length === 0) {
    throw new Error('Copy Template tab is empty');
  }
  
  // First row is headers: ['Deliverable', 'Name', 'en-US', 'es-MX', ...]
  const headers = data[0];
  
  // Validate structure
  if (headers[0] !== 'Deliverable' || headers[1] !== 'Name') {
    throw new Error('Invalid Excel structure. Expected columns: Deliverable, Name, [markets...]');
  }
  
  // Extract market codes (all columns after 'Name')
  const markets = headers.slice(2);
  
  // Parse data rows
  const rows = [];
  
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    
    if (!row[0] || !row[1]) continue; // Skip empty rows
    
    const content = {};
    markets.forEach((market, idx) => {
      content[market] = row[idx + 2] || ''; // +2 because first 2 cols are Deliverable/Name
    });
    
    rows.push({
      deliverable: row[0],
      field: row[1],
      content
    });
  }
  
  return { markets, rows };
}
```

### Step 3: Parse Asset Requirements Tab (Tab 2)
```javascript
function parseRequirementsTab(worksheet) {
  if (!worksheet) return []; // Tab doesn't exist
  
  const data = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
  
  if (data.length === 0) return [];
  
  const headers = data[0];
  
  // Expected headers: Deliverable, Asset Name, Width (px), Height (px), Max File Size, Formats, Filename Format, Notes
  const requirements = [];
  
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    
    if (!row[0]) continue; // Skip empty rows
    
    requirements.push({
      deliverable: row[0] || '',
      assetName: row[1] || '',
      width: row[2] || null,
      height: row[3] || null,
      maxFileSize: row[4] || '',
      formats: row[5] || '',
      filenameFormat: row[6] || '',
      notes: row[7] || ''
    });
  }
  
  return requirements;
}
```

### Step 4: Validate and Group Data
```javascript
function groupRowsByDeliverable(rows) {
  const grouped = {};
  
  rows.forEach(row => {
    if (!grouped[row.deliverable]) {
      grouped[row.deliverable] = [];
    }
    grouped[row.deliverable].push(row);
  });
  
  return grouped;
}

function validateMarkets(markets, knownMarkets) {
  // knownMarkets from data/markets.json
  const warnings = [];
  
  markets.forEach(market => {
    const isKnown = knownMarkets.some(m => m.code === market);
    if (!isKnown) {
      warnings.push(`Unknown market code: ${market}`);
    }
  });
  
  return warnings;
}
```

## üîß Complete Implementation

```javascript
// lib/excelParser.js
import * as XLSX from 'xlsx';
import marketsData from '@/data/markets.json';

export async function parseExcelFile(file) {
  try {
    // Step 1: Read file
    const arrayBuffer = await file.arrayBuffer();
    const workbook = XLSX.read(arrayBuffer, { type: 'array' });
    
    const warnings = [];
    
    // Step 2: Find Copy Template tab
    let copyTab = workbook.Sheets['Copy Template'];
    if (!copyTab) {
      // Try to find it by index (first sheet)
      copyTab = workbook.Sheets[workbook.SheetNames[0]];
      warnings.push('Copy Template tab not found by name, using first sheet');
    }
    
    if (!copyTab) {
      throw new Error('No valid sheets found in Excel file');
    }
    
    // Step 3: Parse Copy Template
    const { markets, rows } = parseCopyTab(copyTab);
    
    // Step 4: Validate markets
    const marketWarnings = validateMarkets(markets, marketsData.markets);
    warnings.push(...marketWarnings);
    
    // Step 5: Parse Requirements tab (if exists)
    let requirements = [];
    const requirementsTab = workbook.Sheets['Asset Requirements'];
    if (requirementsTab) {
      requirements = parseRequirementsTab(requirementsTab);
    } else {
      warnings.push('Asset Requirements tab not found (optional)');
    }
    
    // Step 6: Group data
    const grouped = groupRowsByDeliverable(rows);
    
    return {
      markets,
      rows,
      grouped,
      requirements,
      metadata: {
        filename: file.name,
        tabNames: workbook.SheetNames,
        parsedAt: new Date(),
        warnings
      }
    };
    
  } catch (error) {
    console.error('Error parsing Excel file:', error);
    throw new Error(`Failed to parse ${file.name}: ${error.message}`);
  }
}

// Helper: Parse Copy Template tab
function parseCopyTab(worksheet) {
  const data = XLSX.utils.sheet_to_json(worksheet, { 
    header: 1,
    defval: '',
    blankrows: false  // Skip completely blank rows
  });
  
  if (data.length === 0) {
    throw new Error('Copy Template tab is empty');
  }
  
  const headers = data[0];
  
  // Validate structure
  if (!headers[0] || !headers[1]) {
    throw new Error('Invalid Excel structure. First two columns must be Deliverable and Name');
  }
  
  // Extract market codes (all columns after position 1)
  const markets = headers.slice(2).filter(h => h); // Filter out empty headers
  
  if (markets.length === 0) {
    throw new Error('No market columns found in Excel file');
  }
  
  // Parse data rows
  const rows = [];
  
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    
    // Skip if both deliverable and field are empty
    if (!row[0] && !row[1]) continue;
    
    if (!row[0] || !row[1]) {
      console.warn(`Row ${i + 1} has missing deliverable or field name, skipping`);
      continue;
    }
    
    const content = {};
    markets.forEach((market, idx) => {
      content[market] = row[idx + 2] || '';
    });
    
    rows.push({
      deliverable: String(row[0]).trim(),
      field: String(row[1]).trim(),
      content
    });
  }
  
  return { markets, rows };
}

// Helper: Parse Requirements tab
function parseRequirementsTab(worksheet) {
  const data = XLSX.utils.sheet_to_json(worksheet, { 
    header: 1,
    blankrows: false 
  });
  
  if (data.length <= 1) return []; // Only header or empty
  
  const requirements = [];
  
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    
    if (!row[0]) continue;
    
    requirements.push({
      deliverable: row[0] || '',
      assetName: row[1] || '',
      width: row[2] || null,
      height: row[3] || null,
      maxFileSize: row[4] || '',
      formats: row[5] || '',
      filenameFormat: row[6] || '',
      notes: row[7] || ''
    });
  }
  
  return requirements;
}

// Helper: Group rows by deliverable
function groupRowsByDeliverable(rows) {
  const grouped = {};
  
  rows.forEach(row => {
    if (!grouped[row.deliverable]) {
      grouped[row.deliverable] = {
        name: row.deliverable,
        fields: []
      };
    }
    
    grouped[row.deliverable].fields.push({
      name: row.field,
      content: row.content
    });
  });
  
  return grouped;
}

// Helper: Validate markets
function validateMarkets(markets, knownMarkets) {
  const warnings = [];
  
  markets.forEach(market => {
    const isKnown = knownMarkets.some(m => m.code === market);
    if (!isKnown) {
      warnings.push(`Unknown market code: "${market}" - may not be in standard list`);
    }
  });
  
  return warnings;
}

// Helper: Get content for specific market
export function getMarketContent(parsedData, marketCode) {
  return parsedData.rows.map(row => ({
    deliverable: row.deliverable,
    field: row.field,
    content: row.content[marketCode] || ''
  }));
}

// Helper: Check if content is complete
export function validateCompleteness(parsedData) {
  const issues = [];
  
  parsedData.rows.forEach((row, index) => {
    parsedData.markets.forEach(market => {
      const content = row.content[market];
      
      // Check for placeholder text
      if (content.includes('[') && content.includes('translation needed')) {
        issues.push({
          row: index + 2, // +2 for header row and 0-index
          deliverable: row.deliverable,
          field: row.field,
          market,
          issue: 'Contains placeholder text'
        });
      }
      
      // Check for empty required fields
      if (!content || content.trim() === '') {
        issues.push({
          row: index + 2,
          deliverable: row.deliverable,
          field: row.field,
          market,
          issue: 'Empty content'
        });
      }
    });
  });
  
  return issues;
}
```

## üìä Usage Examples

### Example 1: Parse and Generate Word Docs
```javascript
import { parseExcelFile } from '@/lib/excelParser';
import { generateWordDocument } from '@/lib/wordGenerator';

// User drops Excel file
const parsedExcel = await parseExcelFile(file);

// Generate Word doc for each market
parsedExcel.markets.forEach(async (marketCode) => {
  const market = marketsData.markets.find(m => m.code === marketCode);
  
  // Get content for this market
  const marketContent = getMarketContent(parsedExcel, marketCode);
  
  // Convert to deliverable structure
  const deliverable = {
    sections: Object.values(parsedExcel.grouped)
  };
  
  // Generate Word doc
  const doc = generateWordDocument(deliverable, market);
  const blob = await documentToBlob(doc);
  
  // Download or package
});
```

### Example 2: Validate Before Processing
```javascript
const parsedExcel = await parseExcelFile(file);

// Check completeness
const issues = validateCompleteness(parsedExcel);

if (issues.length > 0) {
  // Show warnings to user
  console.warn(`Found ${issues.length} incomplete fields`);
  // User can choose to continue or fix issues
}

// Check for warnings
if (parsedExcel.metadata.warnings.length > 0) {
  // Display warnings in UI
}
```

## ‚úÖ Testing Checklist

- [ ] Parse Excel generated by Phase 1 (perfect structure)
- [ ] Parse manually edited Excel (extra columns, reordered)
- [ ] Handle missing tabs gracefully
- [ ] Detect unknown market codes
- [ ] Handle empty cells
- [ ] Handle merged cells (warn user)
- [ ] Multiple sheets with same name (use first)
- [ ] Validate data completeness
- [ ] Handle large files (1000+ rows)

## üö® Edge Cases to Handle

1. **Reordered Columns** - Market columns in different order
2. **Extra Columns** - User added custom columns (ignore them)
3. **Missing Tab 2** - Asset Requirements not present (optional)
4. **Merged Cells** - Excel allows this, but breaks our parser
5. **Formula Cells** - Show computed value, not formula
6. **Empty Markets** - Column exists but all cells empty
7. **Non-standard Headers** - "Deliverable Name" instead of "Deliverable"
8. **Hidden Rows/Columns** - Still parse them

## üé® Integration with UI

```javascript
// In FileDropZone component
async function handleExcelDrop(file) {
  try {
    setLoading(true);
    
    const parsed = await parseExcelFile(file);
    
    // Show warnings if any
    if (parsed.metadata.warnings.length > 0) {
      setWarnings(parsed.metadata.warnings);
    }
    
    // Check completeness
    const issues = validateCompleteness(parsed);
    if (issues.length > 0) {
      setValidationIssues(issues);
    }
    
    // Store parsed data for preview
    setParsedData(parsed);
    
    // Move to preview step
    setStep('preview');
    
  } catch (error) {
    setError(error.message);
  } finally {
    setLoading(false);
  }
}
```

## üìä Expected Performance

- **Small file (100 rows, 5 markets):** <100ms
- **Medium file (500 rows, 10 markets):** <300ms
- **Large file (2000 rows, 15 markets):** <1 second
- **Memory:** ~1MB per 100 rows

## üîó Next Steps

After implementing this, read:
- `conversion-helpers-guide.md` for data transformation utilities
- `component-specs.md` for UI integration
- `qa-engine-guide.md` for QA processing
